<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
   <generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator>
   <link href="http://alitoyserkani.me/feed.xml" rel="self" type="application/atom+xml" />
   <link href="http://alitoyserkani.me/" rel="alternate" type="text/html" />
   <updated>2017-12-28T18:22:03+00:00</updated>
   <id>http://alitoyserkani.me/</id>
   <title type="html">Ali Toyserkani - Personal Website</title>
   <subtitle>Ali Toyserkani - Personal WebSite</subtitle>
   <author>
      <name>Ali Toyserkani</name>
   </author>
   <entry>
      <title type="html">Traffic Sign Recognition with Tensorflow</title>
      <link href="http://alitoyserkani.me/robotics/traffic-signs/" rel="alternate" type="text/html" title="Traffic Sign Recognition with Tensorflow" />
      <published>2017-03-31T00:00:00+00:00</published>
      <updated>2017-03-31T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/traffic-signs</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/traffic-signs/">&lt;h1 id="introduction"&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In this project, I used a convolutional neural network (CNN) to classify traffic signs. I trained and validated a model so it can classify traffic sign images using the &lt;a href="http://benchmark.ini.rub.de/"&gt;German Traffic Sign Dataset&lt;/a&gt;. After the model is trained, I tried out the model on images of traffic signs that I took with my smartphone camera.&lt;/p&gt;

&lt;p&gt;My final model results are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Training set accuracy of 97.5%&lt;/li&gt;
  &lt;li&gt;Validation set accuracy of  98.5%&lt;/li&gt;
  &lt;li&gt;Test set accuracy of 97.2%&lt;/li&gt;
  &lt;li&gt;New Test set accuracy of 100% (6 new images taken by me)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is the &lt;a href="https://github.com/jokla/CarND-Traffic-Sign-Classifier-Project/blob/master/Traffic_Sign_Classifier.ipynb"&gt;project code&lt;/a&gt;. Please note that I used only the CPU of my laptop to train the network.&lt;/p&gt;

&lt;p&gt;The steps of this project are the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Load the data set&lt;/li&gt;
  &lt;li&gt;Explore, summarize and visualize the data set&lt;/li&gt;
  &lt;li&gt;Design, train and test a model architecture&lt;/li&gt;
  &lt;li&gt;Use the model to make predictions on new images&lt;/li&gt;
  &lt;li&gt;Analyze the softmax probabilities of the new images&lt;/li&gt;
  &lt;li&gt;Summarize the results with a written report&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="data-set-summary--exploration"&gt;Data Set Summary &amp;amp; Exploration&lt;/h1&gt;

&lt;h2 id="1-basic-summary-of-the-data-set"&gt;1. Basic summary of the data set&lt;/h2&gt;

&lt;p&gt;I used the Pandas library to calculate summary statistics of the traffic
signs data set:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The size of original training set is 34799&lt;/li&gt;
  &lt;li&gt;The size of the validation set is 4410&lt;/li&gt;
  &lt;li&gt;The size of test set is 12630&lt;/li&gt;
  &lt;li&gt;The shape of a traffic sign image is 32x32x3 represented as integer values (0-255) in the RGB color space&lt;/li&gt;
  &lt;li&gt;The number of unique classes/labels in the data set is 43&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We have to work with images with a resolution of 32x32x3 representing 43 type of different German traffic signs.&lt;/p&gt;

&lt;h2 id="2-exploratory-visualization-of-the-dataset"&gt;2. Exploratory visualization of the dataset&lt;/h2&gt;

&lt;p&gt;Here is an exploratory visualization of the data set. It is a bar chart showing how many samples we have for each class.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/dist_class_training.png" width="500" alt="Distribution Class Training" /&gt;&lt;/p&gt;

&lt;p&gt;We can notice that the distribution is not balanced. We have some classes with less than 300 examples and other well represented with more than 1000 examples. We can analyze now the validation dataset distribution:&lt;/p&gt;

&lt;p&gt;&lt;img src=".https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/dist_class_validation.png" width="500" alt="Distribution Class Validation" /&gt;&lt;/p&gt;

&lt;p&gt;The distributions are very similar. Even if it would be wise to balance the dataset, in this case, I am not sure it would be very useful. In fact, some traffic signs (for example the 20km/h speed limit) could occur less frequently than others (the stop sign for example). For this reason I decided to not balance the dataset.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Class 0: Speed limit (20km/h)                                180 samples
Class 1: Speed limit (30km/h)                                1980 samples
Class 2: Speed limit (50km/h)                                2010 samples
Class 3: Speed limit (60km/h)                                1260 samples
Class 4: Speed limit (70km/h)                                1770 samples
Class 5: Speed limit (80km/h)                                1650 samples
Class 6: End of speed limit (80km/h)                         360 samples
Class 7: Speed limit (100km/h)                               1290 samples
Class 8: Speed limit (120km/h)                               1260 samples
Class 9: No passing                                          1320 samples
Class 10: No passing for vehicles over 3.5 metric tons        1800 samples
Class 11: Right-of-way at the next intersection               1170 samples
Class 12: Priority road                                       1890 samples
Class 13: Yield                                               1920 samples
Class 14: Stop                                                690 samples
Class 15: No vehicles                                         540 samples
Class 16: Vehicles over 3.5 metric tons prohibited            360 samples
Class 17: No entry                                            990 samples
Class 18: General caution                                     1080 samples
Class 19: Dangerous curve to the left                         180 samples
Class 20: Dangerous curve to the right                        300 samples
Class 21: Double curve                                        270 samples
Class 22: Bumpy road                                          330 samples
Class 23: Slippery road                                       450 samples
Class 24: Road narrows on the right                           240 samples
Class 25: Road work                                           1350 samples
Class 26: Traffic signals                                     540 samples
Class 27: Pedestrians                                         210 samples
Class 28: Children crossing                                   480 samples
Class 29: Bicycles crossing                                   240 samples
Class 30: Beware of ice/snow                                  390 samples
Class 31: Wild animals crossing                               690 samples
Class 32: End of all speed and passing limits                 210 samples
Class 33: Turn right ahead                                    599 samples
Class 34: Turn left ahead                                     360 samples
Class 35: Ahead only                                          1080 samples
Class 36: Go straight or right                                330 samples
Class 37: Go straight or left                                 180 samples
Class 38: Keep right                                          1860 samples
Class 39: Keep left                                           270 samples
Class 40: Roundabout mandatory                                300 samples
Class 41: End of no passing                                   210 samples
Class 42: End of no passing by vehicles over 3.5 metric tons  210 samples

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id="design-and-test-a-model-architecture"&gt;Design and Test a Model Architecture&lt;/h1&gt;

&lt;h2 id="1-pre-processing"&gt;1. Pre-processing&lt;/h2&gt;

&lt;p&gt;This phase is crucial to improving the performance of the model. First of all, I decided to convert the RGB image into grayscale color. This allows to reduce the numbers of channels in the input of the network without decreasing the performance. In fact, as Pierre Sermanet and Yann LeCun mentioned in their paper &lt;a href="http://yann.lecun.com/exdb/publis/pdf/sermanet-ijcnn-11.pdf"&gt;“Traffic Sign Recognition with Multi-Scale Convolutional Networks”&lt;/a&gt;, using color channels did not seem to improve the classification accuracy. Also, to help the training phase, I normalized each image to have a range from 0 to 1 and translated to get zero mean. I also applied the &lt;a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization"&gt;Contrast Limited Adaptive Histogram Equalization&lt;/a&gt; (CLAHE), an algorithm for local contrast enhancement, which uses histograms computed over different tile regions of the image. Local details can, therefore, be enhanced even in areas that are darker or lighter than most of the image. This should help the feature exaction.&lt;/p&gt;

&lt;p&gt;Here the function I used to pre-process each image in the dataset:&lt;/p&gt;

&lt;div class="language-python highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pre_processing_single_img&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;img_y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cv2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cvtColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cv2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;COLOR_BGR2YUV&lt;/span&gt;&lt;span class="p"&gt;))[:,:,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;img_y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img_y&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;255.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;float32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;img_y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exposure&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;equalize_adapthist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img_y&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;img_y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;img_y&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img_y&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;img_y&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Steps:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Convert the image to &lt;a href="https://en.wikipedia.org/wiki/YUV"&gt;YUV&lt;/a&gt; and extract Y Channel that correspond to the grayscale image:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;img_y = cv2.cvtColor(img, (cv2.COLOR_BGR2YUV))[:,:,0]&lt;/code&gt;
 Y stands for the luma component (the brightness) and U and V are the chrominance (color) components.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Normalize the image to have a range from 0 to 1: &lt;br /&gt;
` img_y = (img_y / 255.).astype(np.float32) `&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Contrast Limited Adaptive Histogram Equalization (see &lt;a href="http://scikit-image.org/docs/dev/api/skimage.exposure.html#skimage.exposure.equalize_adapthist"&gt;here&lt;/a&gt; for more information) and translate the result to have mean zero: &lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;img_y = (exposure.equalize_adapthist(img_y,) - 0.5)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally reshape the image from (32x32) to (32x32x1), the format required by tensorflow: &lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;img_y = img_y.reshape(img_y.shape + (1,))&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is an example of a traffic sign image before and after the processing:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/original_samples3.png" width="360" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/prepro_train.png" width="360" /&gt;&lt;/p&gt;

&lt;p&gt;Initially, I used &lt;code class="highlighter-rouge"&gt;.exposure.adjust_log&lt;/code&gt;, that it is quite fast but finally I decided to use &lt;code class="highlighter-rouge"&gt;exposure.equalize_adapthist&lt;/code&gt;, that gives a better accuracy.&lt;/p&gt;

&lt;h2 id="2-augmentation"&gt;2. Augmentation&lt;/h2&gt;

&lt;p&gt;To add more data to the data set, I created two new datasets starting from the original training dataset, composed by 34799 examples. In this way, I obtain 34799x3 = 104397 samples in the training dataset.&lt;/p&gt;

&lt;h2 id="keras-imagedatagenerator"&gt;Keras ImageDataGenerator&lt;/h2&gt;
&lt;p&gt;I used the Keras function &lt;a href="https://keras.io/preprocessing/image/"&gt;ImageDataGenerator&lt;/a&gt; to generate new images with the following settings:&lt;/p&gt;

&lt;div class="language-python highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;
&lt;span class="n"&gt;datagen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImageDataGenerator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;rotation_range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;width_shift_range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;height_shift_range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;shear_range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;zoom_range&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;horizontal_flip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;dim_ordering&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'tf'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;fill_mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'nearest'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

 &lt;span class="c"&gt;# configure batch size and retrieve one batch of images&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;X_batch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y_batch&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;datagen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;batch_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;X_train&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;shuffle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_batch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;X_train_aug&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X_batch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'uint8'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y_train_aug&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y_batch&lt;/span&gt;
    &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;To each picture in the training dataset, a rotation, a translation, a zoom and a shear transformation is applied.&lt;/p&gt;

&lt;p&gt;Here is an example of an original image and an augmented image:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/original_samples.png" width="360" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/keras_prepro_samples.png" width="360" /&gt;&lt;/p&gt;

&lt;h2 id="motion-blur"&gt;Motion Blur&lt;/h2&gt;
&lt;p&gt;Motion blur is the apparent streaking of rapidly moving objects in a still image. I thought it is a good idea add motion blur to the image since they are taken from a camera placed on a moving car.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/original_samples1.png" width="360" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/mb_prepro_samples.png" width="360" /&gt;&lt;/p&gt;

&lt;h2 id="3-final-model-architecture"&gt;3. Final model architecture&lt;/h2&gt;

&lt;p&gt;I started from the LeNet network and I modified it using the multi-scale features took inspiration from the model presented in &lt;a href="http://yann.lecun.com/exdb/publis/pdf/sermanet-ijcnn-11.pdf"&gt;Pierre Sermanet and Yann LeCun&lt;/a&gt; paper. Finally, I increased the number of filters used in the first two convolutions.
We have in total 3 layers: 2 convolutional layers for feature extraction and one fully connected layer used. Note that my network has one convolutional layer less than the [Pierre Sermanet and Yann LeCun (http://yann.lecun.com/exdb/publis/pdf/sermanet-ijcnn-11.pdf) version.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style="text-align: center"&gt;Layer&lt;/th&gt;
      &lt;th style="text-align: center"&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Input&lt;/td&gt;
      &lt;td style="text-align: center"&gt;32x32x1 Grayscale image&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Convolution 3x3&lt;/td&gt;
      &lt;td style="text-align: center"&gt;1x1 stride, same padding, outputs 28x28x12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;RELU&lt;/td&gt;
      &lt;td style="text-align: center"&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Max pooling&lt;/td&gt;
      &lt;td style="text-align: center"&gt;2x2 stride,  outputs 14x14x12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Dropout (a)&lt;/td&gt;
      &lt;td style="text-align: center"&gt;0.7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Convolution 3x3&lt;/td&gt;
      &lt;td style="text-align: center"&gt;1x1 stride, same padding, outputs 10x10x24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;RELU&lt;/td&gt;
      &lt;td style="text-align: center"&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Max pooling&lt;/td&gt;
      &lt;td style="text-align: center"&gt;2x2 stride, output = 5x5x24.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Dropout  (b)&lt;/td&gt;
      &lt;td style="text-align: center"&gt;0.6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Fully connected&lt;/td&gt;
      &lt;td style="text-align: center"&gt;max_pool(a) + (b) flattend. input = 1188. Output = 320&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Dropout  (c)&lt;/td&gt;
      &lt;td style="text-align: center"&gt;0.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Fully connected&lt;/td&gt;
      &lt;td style="text-align: center"&gt;Input = 320. Output = n_classes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style="text-align: center"&gt;Softmax&lt;/td&gt;
      &lt;td style="text-align: center"&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To train the model I used 20 epochs with a batch size of 128, the &lt;a href="https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer"&gt;AdamOptimizer&lt;/a&gt;(see paper &lt;a href="https://arxiv.org/pdf/1412.6980v8.pdf"&gt;here&lt;/a&gt;) with a learning rate of 0.001. The training phase is quite slow using only CPU, that’s why I used only 20 epochs.&lt;/p&gt;

&lt;p&gt;My final model results were:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Training set accuracy of 97.5%&lt;/li&gt;
  &lt;li&gt;Validation set accuracy of  98.5%&lt;/li&gt;
  &lt;li&gt;Test set accuracy of 97.2%&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="first-attempt-validation-accuracy-915"&gt;First attempt: validation accuracy 91.5%&lt;/h3&gt;

&lt;p&gt;Initially, I started with the &lt;a href="http://yann.lecun.com/exdb/lenet/"&gt;LeNet architecture&lt;/a&gt;, a convolutional network designed for handwritten and machine-printed character recognition.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/lenet5.png" width="900" /&gt;&lt;/p&gt;

&lt;p&gt;I used the the following preprocess pipeline:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Convert in YUV, keep the Y&lt;/li&gt;
  &lt;li&gt;Adjust the exposure&lt;/li&gt;
  &lt;li&gt;Normalization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parameters:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EPOCHS = 10&lt;/li&gt;
  &lt;li&gt;BATCH_SIZE = 128&lt;/li&gt;
  &lt;li&gt;Learning rate = 0.001&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Number of training examples = 34799 &lt;br /&gt;
Number of validation examples = 4410 &lt;br /&gt;
Number of testing examples = 12630&lt;/p&gt;

&lt;p&gt;At each step, I will mention only the changes I adopted to improve the accuracy.&lt;/p&gt;

&lt;h3 id="second-attempt-validation-accuracy-931"&gt;Second attempt: validation accuracy 93.1%&lt;/h3&gt;
&lt;p&gt;I added Dropout after each layer of the network LeNet:  &lt;br /&gt;
1) &lt;code class="highlighter-rouge"&gt;0.9&lt;/code&gt; (after C1) &lt;br /&gt;
2) &lt;code class="highlighter-rouge"&gt;0.7&lt;/code&gt; (after C3)  &lt;br /&gt;
3) &lt;code class="highlighter-rouge"&gt;0.6&lt;/code&gt; (after C5) &lt;br /&gt;
4) &lt;code class="highlighter-rouge"&gt;0.5&lt;/code&gt; (after F6)&lt;/p&gt;

&lt;h3 id="third-attempt-validation-accuracy-933"&gt;Third attempt: validation accuracy 93.3%&lt;/h3&gt;
&lt;p&gt;I changed the network using multi-scale features as suggested in the paper &lt;a href="https://www.google.fr/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0ahUKEwi079aWzOjSAhWHJ8AKHUx_ARkQFggdMAA&amp;amp;url=http%3A%2F%2Fyann.lecun.org%2Fexdb%2Fpublis%2Fpsgz%2Fsermanet-ijcnn-11.ps.gz&amp;amp;usg=AFQjCNGTHlNOHKmIxaKYw3_h-VYrsgpCag&amp;amp;sig2=llvR7_9QizK3hkAgkmUKTw"&gt;Traffic Sign Recognition with Multi-Scale Convolutional Networks&lt;/a&gt; and use only one fully connected layer at the end of the network.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/net.png" width="800" /&gt;&lt;/p&gt;

&lt;h3 id="fourth-attempt-validation-accuracy-946"&gt;Fourth attempt: validation accuracy 94.6%&lt;/h3&gt;
&lt;p&gt;I augmented the training set using the Keras function &lt;a href="https://keras.io/preprocessing/image/"&gt;ImageDataGenerator&lt;/a&gt;. In this way, I double the training set.&lt;/p&gt;

&lt;p&gt;Number of training examples = 34799x2 = 69598 &lt;br /&gt;
Number of validation examples = 4410&lt;/p&gt;

&lt;p&gt;I Used Dropout with the follow probability (referred &lt;a href="https://github.com/jokla/CarND-Traffic-Sign-Classifier-Project/blob/master/writeup.md#3-final-model-architecture"&gt;this table&lt;/a&gt;): &lt;br /&gt;
a) &lt;code class="highlighter-rouge"&gt;0.8&lt;/code&gt; &lt;br /&gt;
b) &lt;code class="highlighter-rouge"&gt;0.7&lt;/code&gt; &lt;br /&gt;
c) &lt;code class="highlighter-rouge"&gt;0.6 &lt;/code&gt;&lt;/p&gt;

&lt;h3 id="fifth-attempt-validation-accuracy-961"&gt;Fifth attempt: validation accuracy 96.1%&lt;/h3&gt;
&lt;p&gt;Since the training accuracy was not very high, I decided to increase the number of filters in the first two convolutional layers. &lt;br /&gt;
First layer: from 6 to 12 filters.   &lt;br /&gt;
Second layer: from 16 to 24 filters.&lt;/p&gt;

&lt;h3 id="final-attempt-validation-accuracy-985"&gt;Final attempt: validation accuracy 98.5%&lt;/h3&gt;
&lt;p&gt;I augmented the data adding the motion blur to each sample of the training data. Hence, I triplicate the number of samples in the training set. In addition, I added the L2 regularization and I used the function &lt;code class="highlighter-rouge"&gt;equalize_adapthist&lt;/code&gt; instead of &lt;code class="highlighter-rouge"&gt;.exposure.adjust_log&lt;/code&gt; during the image preprocessing.&lt;/p&gt;

&lt;h2 id="performance-on-the-test-set"&gt;Performance on the test set&lt;/h2&gt;
&lt;p&gt;Finally I evaluated the performance of my model with the test set.&lt;/p&gt;

&lt;h3 id="accuracy"&gt;Accuracy&lt;/h3&gt;
&lt;p&gt;The accuracy was equal to  97.2%.&lt;/p&gt;

&lt;h3 id="precision"&gt;Precision&lt;/h3&gt;
&lt;p&gt;The Precision  was equal to 96.6% &lt;br /&gt;
The precision is the ratio &lt;code class="highlighter-rouge"&gt;tp / (tp + fp)&lt;/code&gt; where &lt;code class="highlighter-rouge"&gt;tp&lt;/code&gt; is the number of true positives and &lt;code class="highlighter-rouge"&gt;fp&lt;/code&gt; the number of false positives. The precision is intuitively the ability of the classifier not to label as positive a sample that is negative.&lt;/p&gt;

&lt;h3 id="recall"&gt;Recall&lt;/h3&gt;
&lt;p&gt;The recall  was equal to  97.2%
The recall is the ratio &lt;code class="highlighter-rouge"&gt;tp / (tp + fn)&lt;/code&gt; where &lt;code class="highlighter-rouge"&gt;tp&lt;/code&gt; is the number of true positives and &lt;code class="highlighter-rouge"&gt;fn&lt;/code&gt; the number of false negatives. The recall is intuitively the ability of the classifier to find all the positive samples.&lt;/p&gt;

&lt;h3 id="confusion-matrix"&gt;Confusion matrix&lt;/h3&gt;

&lt;p&gt;Let’s analyze the &lt;a href="https://en.wikipedia.org/wiki/Confusion_matrix"&gt;confusion matrix&lt;/a&gt;:&lt;/p&gt;

&lt;div&gt;
    &lt;a href="https://plot.ly/~jokla/1/?share_key=DmJjGBAv9EQXNjMc5jDWCT" target="_blank" title="Plot 1" style="display: block; text-align: center;"&gt;&lt;img src="https://plot.ly/~jokla/1.png?share_key=DmJjGBAv9EQXNjMc5jDWCT" alt="Plot 1" style="max-width: 100%;width: 600px;" width="900" onerror="this.onerror=null;this.src='https://plot.ly/404.png';" /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;You can click on the picture to interact with the map.&lt;/p&gt;

&lt;p&gt;We can notice that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;28/60 samples of to the class 19 (Dangerous curve to the left) are misclassified as samples belonging to the class 23 (Slippery road). This can be explained by the fact that the class number 19 is underrepresented in the training set: it has only 180 samples.&lt;/li&gt;
  &lt;li&gt;34/630 samples of to the class 5 (Speed limit 80km/h) are misclassified as samples belonging to the class 2 (Speed limit 50km/h).&lt;/li&gt;
  &lt;li&gt;The model is not very good to classify the class number 30 (Beware of ice/snow), it classified samples in a wrong way 61 times.&lt;/li&gt;
  &lt;li&gt;The model produces 80 false positives for the class 23.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id="test-a-model-on-new-images"&gt;Test a Model on New Images&lt;/h1&gt;

&lt;p&gt;Here are five traffic signs from some pictures I took in France with my smartphone: &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/11_Rightofway.jpg" width="100" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/25_RoadWork.jpg" width="100" /&gt;  &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/14_Stop.jpg" width="100" /&gt; &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/17_Noentry.jpg" width="100" /&gt;  &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/12_PriorityRoad.jpg" width="100" /&gt;  &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/33_RightOnly.jpg" width="100" /&gt;&lt;/p&gt;

&lt;p&gt;Here are the results of the prediction:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the first image is the test image&lt;/li&gt;
  &lt;li&gt;the second one is a random picture of the same class of the prediction&lt;/li&gt;
  &lt;li&gt;the third one is a  plot showing the top five soft max probabilities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign1.png" width="480" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign2.png" width="480" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign3.png" width="480" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign4.png" width="480" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign5.png" width="480" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/new_sign6.png" width="480" /&gt;&lt;/p&gt;

&lt;p&gt;The model was able to correctly guess 6 of the 6 traffic signs, which gives an accuracy of 100%. Nice!&lt;/p&gt;

&lt;h1 id="visualize-the-neural-networks-state-with-test-images"&gt;Visualize the Neural Network’s State with Test Images&lt;/h1&gt;

&lt;p&gt;We can understand what the weights of a neural network look like better by plotting their feature maps. After successfully training your neural network you can see what it’s feature maps look like by plotting the output of the network’s weight layers in response to a test stimuli image. From these plotted feature maps, it’s possible to see what characteristics of an image the network finds interesting. For a sign, maybe the inner network feature maps react with high activation to the sign’s boundary outline or the contrast in the sign’s painted symbol.&lt;/p&gt;

&lt;p&gt;Here the output of the first convolution layer:&lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/visualize1.png" width="700" /&gt; &lt;br /&gt;
Here the output of the second convolution layer:&lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/visualize2.png" width="700" /&gt;&lt;/p&gt;

&lt;p&gt;We can notice that the CNN learned to detect useful features on its own. We can see in the first picture some edges of the sign for example.&lt;/p&gt;

&lt;p&gt;Now another example using a test picture with no sign on it:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/no_sign.png" width="100" /&gt;&lt;/p&gt;

&lt;p&gt;In this case the CNN does not recognize any useful features. The activations of the first feature map appear to contain mostly noise:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-31-traffic-signs/visualize1_nosign.png" width="700" /&gt;&lt;/p&gt;

&lt;h1 id="final-considerations"&gt;Final considerations&lt;/h1&gt;

&lt;h2 id="premise"&gt;Premise:&lt;/h2&gt;
&lt;p&gt;Only CPU was used to train the network. I had to use only the CPU of my laptop because I didn’t have any good GPU at my disposal. I choose to not use any online service like AWS or FloydHub, mostly because I was waiting for the arrival of the GTX 1080. Unfortunately, it did not arrive in time for this project. This required me to use a small network and to keep the number of epochs around 20.&lt;/p&gt;

&lt;h2 id="some-possible-improvements"&gt;Some possible improvements:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;I would use Keras to define the network and its function ImageDataGenerator to generate augmented samples on the fly. Using more data could improve the performance of the model. In my case, I have generated an augmented dataset once, saved it on the disk and used it every time to train. It would be useful to generate randomly the dataset each time before the training.&lt;/li&gt;
  &lt;li&gt;The confusion matrix gives us suggestions to improve the model (see section &lt;code class="highlighter-rouge"&gt;Confusion matrix&lt;/code&gt;). There are some classes with low precision or recall. It would be useful to try to add more data for these classes. For example, I would generate new samples for the class 19 (Dangerous curve to the left) since it has only 180 samples and the model.&lt;/li&gt;
  &lt;li&gt;The accuracy for the training set is 0.975. This means that the model is probably underfitting a little bit. I tried to make a deeper network (adding more layers) and increasing the number of filters but it was too slow to train it using the CPU only.&lt;/li&gt;
  &lt;li&gt;The model worked well with new images taken with my camera (100% of accuracy). It would be useful to test the model by using more complicated examples.&lt;/li&gt;
&lt;/ul&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Deep Learning" />
      <category term="Tensorflow" />
      <summary type="html">Designed a CNN inspired by LeNet architecture</summary>
   </entry>
   <entry>
      <title type="html">Finding Lane Lines on the Road</title>
      <link href="http://alitoyserkani.me/robotics/lane-detection/" rel="alternate" type="text/html" title="Finding Lane Lines on the Road" />
      <published>2017-03-10T00:00:00+00:00</published>
      <updated>2017-03-10T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/lane-detection</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/lane-detection/">&lt;h1 id="overview"&gt;Overview:&lt;/h1&gt;

&lt;p&gt;The goal of this project is to make a pipeline that finds lane lines on the road using Python and OpenCV. See an example:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/solidWhiteRight.jpg" width="360" alt="Combined Image" /&gt;    &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/laneLines_thirdPass.jpg" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;p&gt;The pipeline will be tested on some images and videos provided by Udacity. The following assumptions are made:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The camera always has the same position with respect to the road&lt;/li&gt;
  &lt;li&gt;There is always a visible white or yellow line on the road&lt;/li&gt;
  &lt;li&gt;We don’t have any vehicle in front of us&lt;/li&gt;
  &lt;li&gt;We consider highway scenario with good weather conditions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href="https://github.com/jokla/CarND-LaneLines-P1"&gt;Here&lt;/a&gt; you can find the project.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id="reflection"&gt;Reflection&lt;/h1&gt;

&lt;h2 id="1-pipeline-description"&gt;1. Pipeline description&lt;/h2&gt;

&lt;p&gt;I will use the following picture to show you all the steps:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/original.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="color-selection"&gt;Color selection&lt;/h3&gt;
&lt;p&gt;Firstly, I applied a color filtering to suppress non-yellow and non-white colors. The pixels that were above the thresholds have been retained, and pixels below the threshold have been blacked out.  This is the result:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/mask_color.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;p&gt;I will keep aside this mask and use it later.&lt;/p&gt;

&lt;h3 id="convert-the-color-image-in-grayscale"&gt;Convert the color image in grayscale&lt;/h3&gt;
&lt;p&gt;The original image is converted in grayscale. In this way we have only one channel:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/gray.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h4 id="use-canny-for-edge-detection"&gt;Use Canny for edge detection&lt;/h4&gt;
&lt;p&gt;Before running the &lt;a href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html"&gt;Canny detector&lt;/a&gt;, I applied a &lt;a href="http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html?highlight=gaussianblur#gaussianblur"&gt;Gaussian smoothing&lt;/a&gt; which is essentially a way of suppressing noise and spurious gradients by averaging. The Canny allows detecting the edges in the images. To improve the result, I also used the OpenCV function &lt;code class="highlighter-rouge"&gt;dilate&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;erode&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/canny.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="merge-canny-and-color-selection"&gt;Merge Canny and Color Selection&lt;/h3&gt;
&lt;p&gt;In some cases, the Canny edge detector fails to find the lines. For example, when there is not enough contrast between the asphalt and the line, as in the challenge video (see section &lt;code class="highlighter-rouge"&gt;Optional challenge&lt;/code&gt;). The color selection, on the other hand, doesn’t have this problem. For this reason, I decided to merge the result of the Canny detector and the color selection:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/merge.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="region-of-interest-mask"&gt;Region Of Interest Mask&lt;/h3&gt;
&lt;p&gt;I defined a left and right trapezoidal Region Of Interest (ROI) based on the image size. Since that the front facing camera is mounted in a fix position, we supposed here that the lane lines will always appear in the same region of the image.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/roi.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="run-hough-transform-to-detect-lines"&gt;Run Hough transform to detect lines&lt;/h3&gt;
&lt;p&gt;The Hough transform is used to detect lines in the images. At this step, I applied a slope filter to get rid of horizontal lines. This is the result: &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/hough.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="compute-lines"&gt;Compute lines&lt;/h3&gt;
&lt;p&gt;Now I need to average/extrapolate the result of the Hough transform and draw the two lines onto the image. I used the function  &lt;a href="http://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#fitline"&gt;&lt;code class="highlighter-rouge"&gt;fitLine&lt;/code&gt;&lt;/a&gt;, after having extrapolated the points from the Hough tranform result with the OpenCV function &lt;code class="highlighter-rouge"&gt;findNonZero&lt;/code&gt;. I did this two times, once for the right line and another time for the left line. As a result, I got the slopes of the lines, and I could draw them onto the original picture:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/final.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h1 id="results"&gt;Results:&lt;/h1&gt;

&lt;h2 id="pictures"&gt;Pictures&lt;/h2&gt;
&lt;p&gt;Here some results on test images provided by Udacity: &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/final.png" width="360" alt="Combined Image" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/result1.png" width="360" alt="Combined Image" /&gt;  &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/result2.png" width="360" alt="Combined Image" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/result3.png" width="360" alt="Combined Image" /&gt; &lt;br /&gt;
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/result4.png" width="360" alt="Combined Image" /&gt;     &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/result5.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;p&gt;You can find the original pictures and the results in the folder &lt;code class="highlighter-rouge"&gt;test_images&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="videos"&gt;Videos&lt;/h2&gt;
&lt;p&gt;Here some results on test videos provided by Udacity:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/white.gif" alt="" /&gt; 
&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/yellow.gif" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;You can find the video files here: &lt;a href="https://github.com/jokla/CarND-LaneLines-P1/blob/master/yellow.mp4"&gt;video1&lt;/a&gt;, &lt;a href="https://github.com/jokla/CarND-LaneLines-P1/blob/master/white.mp4"&gt;video2&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="optional-challenge"&gt;Optional challenge:&lt;/h3&gt;

&lt;p&gt;While I got a satisfactory result on the first two videos provided by Udacity, it was not the case for the challenge video. In the challenge video we can identify more difficulties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The color of the asphalt became lighter at a certain point. The Canny edge detector is not able to find the line using the grayscale image (where we lose information about the color)&lt;/li&gt;
  &lt;li&gt;The car is driving on a curving road&lt;/li&gt;
  &lt;li&gt;There are some shadows due to some trees&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To overcome theses problems, I introduced the color mask and resized the ROI. This is the result, using only the color mask (without the canny detection):&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/extra.gif" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;You can find the video file here: &lt;a href="https://github.com/jokla/CarND-LaneLines-P1/blob/master/extra.mp4"&gt;video_challenge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The right line is a little jumpy mainly because of the curve: the function &lt;code class="highlighter-rouge"&gt;fitline&lt;/code&gt; is trying to fit a line on a curvy lane. It would be useful to shrink the ROI in this case, but I preferred to keep the same ROI size used in the first two videos.&lt;/p&gt;

&lt;p&gt;If we analyze the steps using a snapshot from the challenge video, we can notice that the Canny detector is not very useful:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/original_challenge.png" width="360" alt="Combined Image" /&gt; &lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/canny_challenge.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;p&gt;while the color mask is able to detect the lines:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/color_challenge.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;p&gt;Indeed, as you can see in the following picture, we lose valuable color information when we convert the image in grayscale. Moreover, the Canny operator find a lot of edges when we have shadows on the road.&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/gray_challenge.png" width="360" alt="Combined Image" /&gt;&lt;/p&gt;

&lt;h3 id="testing-the-pipeline-on-a-youtube-video"&gt;Testing the pipeline on a YouTube Video:&lt;/h3&gt;

&lt;p&gt;Just out of curiosity, I wanted to test the pipeline on a video extracted from Youtube (see the original video &lt;a href="https://www.youtube.com/watch?v=jwBaGY67olI"&gt;here&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;I noticed that the color selection was not working properly in this case, so I had to tune a little bit the thresholds values. This is the new result using both color selection and Canny:&lt;/p&gt;

&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/jokla/jokla.github.io/master/images/post/2017-03-10-lane-detection/extra_test.gif" alt="" /&gt;&lt;/p&gt;

&lt;p&gt;You can find the video file here: &lt;a href="https://github.com/jokla/CarND-LaneLines-P1/blob/master/extra_test_result.mp4"&gt;video_extra&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It would be wiser to transform the image in the HSV space and to apply the color selection, instead of doing it on the RGB images.&lt;/p&gt;

&lt;h2 id="2-potential-shortcomings-with-the-current-pipeline"&gt;2. Potential shortcomings with the current pipeline&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;This approach could not work properly:
    &lt;ul&gt;
      &lt;li&gt;if the camera is placed at a different position&lt;/li&gt;
      &lt;li&gt;if other vehicles in front are occluding the view&lt;/li&gt;
      &lt;li&gt;if one or more lines are missing&lt;/li&gt;
      &lt;li&gt;at different weather and light condition (fog, rain, or at night)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="3-possible-improvements"&gt;3. Possible improvements&lt;/h2&gt;

&lt;p&gt;Some possible improvements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Perform a color selection in the HSV space, instead of doing it in the RGB images&lt;/li&gt;
  &lt;li&gt;Update the ROI mask dynamically&lt;/li&gt;
  &lt;li&gt;Perform a segmentation of the road&lt;/li&gt;
  &lt;li&gt;Using a better filter to smooth the current estimation, using the previous ones&lt;/li&gt;
  &lt;li&gt;If a line is not detected, we could estimate the current slope using the previous estimations and/or the other line detection&lt;/li&gt;
  &lt;li&gt;Use a moving-edges tracker for the continuous lines&lt;/li&gt;
&lt;/ul&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Computer vision" />
      <category term="OpenCV" />
      <summary type="html">First project of the Udacity Self Driving Car NanoDegree</summary>
   </entry>
   <entry>
      <title type="html">Install Unity3D in Ubuntu</title>
      <link href="http://jokla.me/self-driving-car/install-unity3d-ubuntu/" rel="alternate" type="text/html" title="Install Unity3D in Ubuntu" />
      <published>2017-02-05T00:00:00+00:00</published>
      <updated>2017-02-05T00:00:00+00:00</updated>
      <id>http://jokla.me/self-driving-car/install-unity3d-ubuntu</id>
      <content type="html" xml:base="http://jokla.me/self-driving-car/install-unity3d-ubuntu/">&lt;p&gt;I wanted to test on my laptop this nice project created with Unity3D by &lt;a href="https://github.com/tawnkramer"&gt;tawnkramer&lt;/a&gt;:&lt;/p&gt;

&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/e0AFMilaeMI" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;

&lt;p&gt;Unity3D is used to simulate a self-driving car. A neural network based on the Nvidia’s paper &lt;a href="https://images.nvidia.com/content/tegra/automotive/images/2016/solutions/pdf/end-to-end-dl-using-px.pdf"&gt;“End to End Learning for Self-Driving Cars”&lt;/a&gt; is trained to drive the car down a randomly generated road. You can find the source code &lt;a href="https://github.com/tawnkramer/sdsandbox"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="download-unity-for-linux"&gt;Download Unity for Linux&lt;/h2&gt;

&lt;p&gt;Donwload the last version &lt;a href="https://forum.unity3d.com/threads/unity-on-linux-release-notes-and-known-issues.350256/"&gt;here&lt;/a&gt;. I downloaded the debian package: &lt;a href="http://beta.unity3d.com/download/35e1927e3b6b/public_download.html"&gt;Unity 5.6.0xb3Linux&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;You can install the .deb package via the Ubuntu Software Center and is expected to work on installations of Ubuntu 12.04 or newer.&lt;/p&gt;

&lt;h2 id="fix-black-screen-launching-the-application"&gt;Fix black screen launching the application&lt;/h2&gt;
&lt;p&gt;Initially Unity3D was not able to start properly, I was only getting a grey screen. &lt;a href="https://forum.unity3d.com/threads/dark-grey-screen-fix.448936/"&gt;This solution&lt;/a&gt;, posted by malyzeli, solved the problem.&lt;/p&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Simulation" />
      <summary type="html">Tested in Ubuntu 14.04</summary>
   </entry>
   <entry>
      <title type="html">How to compute frame transformations with Tf (ROS)</title>
      <link href="http://jokla.me/robotics/lookup-transform-ros/" rel="alternate" type="text/html" title="How to compute frame transformations with Tf (ROS) " />
      <published>2016-08-08T00:00:00+00:00</published>
      <updated>2016-08-08T00:00:00+00:00</updated>
      <id>http://jokla.me/robotics/lookup-transform-ros</id>
      <content type="html" xml:base="http://jokla.me/robotics/lookup-transform-ros/">&lt;p&gt;Here a script to compute the transformation between two frames published in /tf in ROS.&lt;br /&gt;
You can &lt;a href="https://gist.github.com/jokla/2630f8dbbd4391d91ab28b2f3f76801a/raw/fbf02a7ec13c4d7f61e9aea86719f866f18f539b/computeTF2frames.py"&gt;download&lt;/a&gt; the python script, modify the name of the topics and run it with&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;python computeTF2frames.py&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The result:&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Translation:  (0.06290424180516997, -0.004345408291908189, 1.1515618071559173)
Rotation:  (-0.5041371308002005, 0.5088056423602352, -0.49116582568647843, 0.4957002151791443)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script src="https://gist.github.com/2630f8dbbd4391d91ab28b2f3f76801a.js"&gt; &lt;/script&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="ROS" />
      <summary type="html">using the function lookupTransform</summary>
   </entry>
   <entry>
      <title type="html">Intrinsic camera calibration for Nao/Romeo/Pepper with Visp</title>
      <link href="http://alitoyserkani.me/robotics/camera-calibration-visp/" rel="alternate" type="text/html" title="Intrinsic camera calibration for Nao/Romeo/Pepper with Visp" />
      <published>2016-08-04T00:00:00+00:00</published>
      <updated>2016-08-04T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/camera-calibration-visp</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/camera-calibration-visp/">&lt;p&gt;We will show here how to estimate the &lt;a href="http://ksimek.github.io/2013/08/13/intrinsic/"&gt;camera intrinsic parameters&lt;/a&gt; for the robot Nao, Romeo or Pepper, using the &lt;a href="http://visp-doc.inria.fr/doxygen/visp-2.8.0/tutorial-calibration.html"&gt;ViSP camera calibration tool&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First of all we need to have ‘ViSP’,&lt;code class="highlighter-rouge"&gt;visp_naoqi&lt;/code&gt; and the C++ SDK from Softbank. You can follow &lt;a href="http://jokla.me/robotics/visp_naoqi/"&gt;this guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once everything is working we can run the program to estimate the parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Go to the build folder of &lt;code class="highlighter-rouge"&gt;visp_naoqi&lt;/code&gt; via terminal&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Run the program &lt;code class="highlighter-rouge"&gt;camera_calibration&lt;/code&gt;:&lt;/p&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Usage: ./sdk/bin/camera_calibration  [ --config &amp;lt;configuration file&amp;gt;.cfg] [--ip &amp;lt;robot address&amp;gt;] [--port &amp;lt;port robot&amp;gt;] [--cam camera_number] [--name camera_name] [--vga] [--help]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Here the explanation of the options:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;[ &lt;code class="highlighter-rouge"&gt;--config &amp;lt;configuration file&amp;gt;.cfg&lt;/code&gt;]  The path to a configuration file where we define the kind of pattern we are using ( size of the grid and  the dimension  of the circle/square). You can find two examples here:(default-chessboard.cfg)[https://github.com/lagadic/visp_naoqi/blob/master/tools/calibration/default-chessboard.cfg] or (default-circles.cfg)[https://github.com/lagadic/visp_naoqi/blob/master/tools/calibration/default-circles.cfg]&lt;/li&gt;
      &lt;li&gt;[&lt;code class="highlighter-rouge"&gt;--ip &amp;lt;robot address&amp;gt;&lt;/code&gt;] Se the IP of the robot.&lt;/li&gt;
      &lt;li&gt;[&lt;code class="highlighter-rouge"&gt;--port &amp;lt;port robot&amp;gt;&lt;/code&gt;] Se the port of the robot: default 9559.&lt;/li&gt;
      &lt;li&gt;[&lt;code class="highlighter-rouge"&gt;--cam camera_number&lt;/code&gt;] Choose the camera you want to use. For Pepper and Nao 0 = TopCamera, 1 = BottomCamera.&lt;/li&gt;
      &lt;li&gt;[&lt;code class="highlighter-rouge"&gt;--name camera_name&lt;/code&gt;] Set the name of the camera.&lt;/li&gt;
      &lt;li&gt;[&lt;code class="highlighter-rouge"&gt;--vga&lt;/code&gt;] if you want to set the camera at the resolution of 640x480. Default resolution: 320x240&lt;br /&gt;
Example:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ ./sdk/bin/camera_calibration --config /udd/gclaudio/romeo/cpp/workspace/visp_naoqi/tools/calibration/default-circles.cfg --cam 0 --name cameraTopPepper --ip 131.254.10.126
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="ViSP" />
      <summary type="html">Intrinsic camera calibration for Nao/Romeo/Pepper with Visp.</summary>
   </entry>
   <entry>
      <title type="html">Speech recognition using ROS and Pocketsphinx</title>
      <link href="http://alitoyserkani.me/robotics/speech-recognition-ros/" rel="alternate" type="text/html" title="Speech recognition using ROS and Pocketsphinx" />
      <published>2016-03-28T00:00:00+00:00</published>
      <updated>2016-03-28T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/speech-recognition-ros</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/speech-recognition-ros/">&lt;p&gt;How to install pocketsphinx on ROS Indigo (Ubuntu 14.04).&lt;/p&gt;

&lt;aside class="sidebar__right"&gt;
&lt;nav class="toc"&gt;
    &lt;header&gt;&lt;h4 class="nav__title"&gt;&lt;i class="fa fa-file-text"&gt;&lt;/i&gt; table of contents&lt;/h4&gt;&lt;/header&gt;
&lt;ul class="toc__menu" id="markdown-toc"&gt;
  &lt;li&gt;&lt;a href="#install-dependecies" id="markdown-toc-install-dependecies"&gt;Install Dependecies&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#clone-and-build-pocketsphinx" id="markdown-toc-clone-and-build-pocketsphinx"&gt;Clone and Build Pocketsphinx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#test-pocketsphinx" id="markdown-toc-test-pocketsphinx"&gt;Test Pocketsphinx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="#command-turtlebot-robot-in-gazebo-using-voice-commands" id="markdown-toc-command-turtlebot-robot-in-gazebo-using-voice-commands"&gt;Command Turtlebot robot in Gazebo using voice commands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

  &lt;/nav&gt;
&lt;/aside&gt;

&lt;h2 id="install-dependecies"&gt;Install Dependecies&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ sudo apt-get install gstreamer0.10-pocketsphinx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ sudo apt-get install python-gst0.10&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ sudo apt-get install gstreamer0.10-gconf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="clone-and-build-pocketsphinx"&gt;Clone and Build Pocketsphinx&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Clone the repository in your catkin src folder:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ git clone https://github.com/mikeferguson/pocketsphinx.git&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Launch the catkin_make command from the catkin workspace folder&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="test-pocketsphinx"&gt;Test Pocketsphinx&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Now we can start the speech recognizer:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ roslaunch pocketsphinx turtlebot_voice_cmd.launch&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;These are the basic commands can be recognized (see file voice_cmd.corpus in the folder demo):&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-text highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;forward
left
right
back
backward
stop
move forward
move right
move left
move back
move backward
halt
half speed
full speed

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Open another terminal to check if the words are recognized:&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$rostopic echo /recognizer/output&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-text highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;jokla@Dell-PC:~/catkin_ws/src$ rostopic echo /recognizer/output 
data: back
---
data: speed
---
data: move right
---
data: move back
---
data: back
---
data: left
---
data: speed
---
data: left
---
data: move right
---
data: stop
---
data: move right
---
data: move left
---
data: full speed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;To each vocal command corresponds a twist command. For example, this is the twist corresponding to the command “back”:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-shell highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;linear: 
  x: &lt;span class="nt"&gt;-0&lt;/span&gt;.4
  y: 0.0
  z: 0.0
angular: 
  x: 0.0
  y: 0.0
  z: 0.0&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id="command-turtlebot-robot-in-gazebo-using-voice-commands"&gt;Command Turtlebot robot in Gazebo using voice commands&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Install &lt;a href="http://wiki.ros.org/turtlebot_simulator"&gt;turtlebot_simulator&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ sudo apt-get install ros-indigo-turtlebot-simulator&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Open the launch file &lt;code class="highlighter-rouge"&gt;turtlebot_voice_cmd&lt;/code&gt; and remap the name of the topic cmd_vel to  &lt;code class="highlighter-rouge"&gt;/mobile_base/commands/velocity&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="language-xml highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="nt"&gt;&amp;lt;node&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"voice_cmd_vel"&lt;/span&gt; &lt;span class="na"&gt;pkg=&lt;/span&gt;&lt;span class="s"&gt;"pocketsphinx"&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"voice_cmd_vel.py"&lt;/span&gt; &lt;span class="na"&gt;output=&lt;/span&gt;&lt;span class="s"&gt;"screen"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;remap&lt;/span&gt; &lt;span class="na"&gt;from=&lt;/span&gt;&lt;span class="s"&gt;"cmd_vel"&lt;/span&gt; &lt;span class="na"&gt;to=&lt;/span&gt;&lt;span class="s"&gt;"/mobile_base/commands/velocity"&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/node&amp;gt;&lt;/span&gt;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this way the node pocketsphinx publishes the velocities in the topic &lt;code class="highlighter-rouge"&gt;/mobile_base/commands/velocity&lt;/code&gt; and gazebo subscribes to it.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Launch simulation (click &lt;a href="http://wiki.ros.org/turtlebot_gazebo/Tutorials/indigo/Gazebo%20Bringup%20Guide"&gt;here&lt;/a&gt; for more info). Note that Gazebo may update its model database when it is started for the first time. This may take a few minutes.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ roslaunch turtlebot_gazebo turtlebot_world.launch&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Now we can start the speech recognizer:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;$ roslaunch pocketsphinx turtlebot_voice_cmd.launch&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;You should be able to control Turtlebot using your voice.&lt;/li&gt;
&lt;/ul&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="ROS" />
      <summary type="html">How to install pocketsphinx on ROS Indigo (Ubuntu 14.04).</summary>
   </entry>
   <entry>
      <title type="html">Places to see in Brittany</title>
      <link href="http://alitoyserkani.me/travel/brittany-to-see/" rel="alternate" type="text/html" title="Places to see in Brittany" />
      <published>2014-12-29T00:00:00+00:00</published>
      <updated>2014-12-29T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/travel/brittany-to-see</id>
      <content type="html" xml:base="http://alitoyserkani.me/travel/brittany-to-see/">&lt;p&gt;I have the fortune to live in one of the best regions of France: Brittany. During my weekend I love traveling around my current city, Rennes. Having said this, I want to share a map collecting the places that I want to see or I have already seen. I will try to improve this map adding comments and pictures.&lt;/p&gt;

&lt;iframe src="https://mapsengine.google.com/map/embed?mid=z_K4lDOSEk7c.kzlVNHXYev4g" width="640" height="480"&gt;&lt;/iframe&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Brittany" />
      <summary type="html">Some tips for holidays in Brittany (with map)</summary>
   </entry>
   <entry>
      <title type="html">Naoqi C++ SDK Installation</title>
      <link href="http://alitoyserkani.me/robotics/install-sdk-c-naoqi/" rel="alternate" type="text/html" title="Naoqi C++ SDK Installation" />
      <published>2014-12-28T00:00:00+00:00</published>
      <updated>2014-12-28T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/install-sdk-c-naoqi</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/install-sdk-c-naoqi/">&lt;aside class="sidebar__right"&gt;
&lt;nav class="toc"&gt;
    &lt;header&gt;&lt;h4 class="nav__title"&gt;&lt;i class="fa fa-file-text"&gt;&lt;/i&gt; table of contents&lt;/h4&gt;&lt;/header&gt;
&lt;ul class="toc__menu" id="markdown-toc"&gt;
  &lt;li&gt;&lt;a href="#prerequisites" id="markdown-toc-prerequisites"&gt;Prerequisites&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href="#installation-ide" id="markdown-toc-installation-ide"&gt;Installation IDE&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#download-software" id="markdown-toc-download-software"&gt;Download software&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href="#c-sdk-and-cross-toolchain" id="markdown-toc-c-sdk-and-cross-toolchain"&gt;C++ SDK and Cross Toolchain&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href="#creation-devtools-and-workspace-folders" id="markdown-toc-creation-devtools-and-workspace-folders"&gt;Creation Devtools and workspace folders&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href="#qibuild" id="markdown-toc-qibuild"&gt;Qibuild&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="#using-qibuild-with-aldebaran-c-sdks" id="markdown-toc-using-qibuild-with-aldebaran-c-sdks"&gt;Using qibuild with Aldebaran C++ SDKs&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href="#optional-test" id="markdown-toc-optional-test"&gt;Optional Test:&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/nav&gt;
&lt;/aside&gt;

&lt;h2 id="prerequisites"&gt;Prerequisites&lt;/h2&gt;

&lt;h3 id="installation-ide"&gt;Installation IDE&lt;/h3&gt;
&lt;p&gt;QT Creator is the IDE recommended by SoftBank Robotics.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Download the installer available &lt;a href="http://qt-project.org/downloads#qt-creator"&gt;here&lt;/a&gt;. In my case the file is named &lt;code class="highlighter-rouge"&gt;qt-opensource-linux-x64-1.6.0-5-online.run&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Go in the folder where you downloaded the installer of qt-creator and give execute permission with:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ chmod a+x qt-opensource-linux-x64-1.6.0-5-online.run&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Run the installer:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ ./qt-opensource-linux-x64-1.6.0-5-online.run&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="download-software"&gt;Download software&lt;/h3&gt;

&lt;h4 id="c-sdk-and-cross-toolchain"&gt;C++ SDK and Cross Toolchain&lt;/h4&gt;
&lt;p&gt;Download the following packages &lt;a href="https://community.aldebaran-robotics.com/resources/"&gt;here&lt;/a&gt; or &lt;a href="https://developer.softbankrobotics.com/us-en/downloads/pepper"&gt;here&lt;/a&gt; for Pepper:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++ SDK 2.3 Linux 64 (or newier version)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="creation-devtools-and-workspace-folders"&gt;Creation Devtools and workspace folders&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Let’s create now some folders useful for the development with the SDK:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ mkdir -p ~/romeo/{devtools,workspace} &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NB: This is just a suggestion, you can manage these folders as you prefer.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Now we can extract the C++ SDK and Cross Toolchain in the devtools folder. Go via terminal in the folder where you downloaded the tools and run:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ tar -zxvf naoqi-sdk-2.3.0.14-linux64.tar.gz -C ~/romeo/devtools/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="qibuild"&gt;Qibuild&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Open a terminal and install Qibuild with &lt;a href="https://pip.pypa.io/en/latest/installing.html#install-pip"&gt;pip&lt;/a&gt;:
&lt;code class="highlighter-rouge"&gt;$ pip install qibuild&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;If you don’t have pip installed you can install it with:
&lt;code class="highlighter-rouge"&gt;$ sudo apt-get install python-pip&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now we add the installation location of Qibuild in the PATH. Open the file bashrc: &lt;code class="highlighter-rouge"&gt;$ gedit ~/.bashrc&lt;/code&gt; and in the end of the file add:&lt;br /&gt;
 &lt;code class="highlighter-rouge"&gt;export PATH=${PATH}:${HOME}/.local/bin&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Open a new terminal and check if Qibuild is correctly installed:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ qibuild --version&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now we have to create a qibuild “worktree”. This path will be the root from where qiBuild searches to find the sources of your projects. We can use the folder we created before: &lt;code class="highlighter-rouge"&gt;~/romeo/workspace&lt;/code&gt;.&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ cd ~/romeo/workspace&lt;/code&gt;
And digit:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ qibuild init&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now we can run: 
&lt;code class="highlighter-rouge"&gt;$ qibuild config --wizard&lt;/code&gt; &lt;br /&gt;
A file will be generated in ~/.config/qi/qibuild.xml. It is shared by all the worktrees you will create. You will be asked to choose a CMake generator, select Unix Makefiles, and to choose a IDE, choose QtCreator (or another if you use a different IDE).&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;:: Please choose a generator:
&amp;gt; 1 (Unix Makefiles)
:: Please choose an IDE
&amp;gt; 2 (QtCreator)
:: Do you want to use qtcreator from /usr/bin/qtcreator?
&amp;gt; Y (Yes)
:: Found a worktree in /udd/fspindle/soft/romeo/workspace_gantry
:: Do you want to configure settings for this worktree? (y/N)
&amp;gt; y
:: Do you want to use a unique build dir? (mandatory when using Eclipse) (y/N)
&amp;gt; N
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;If you see a message like “CMake not found” probably you have to install CMake:&lt;/li&gt;
  &lt;li&gt;&lt;code class="highlighter-rouge"&gt;sudo apt-get update &amp;amp;&amp;amp;  sudo apt-get install cmake &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;We can create, configure and build a new project called “foo”:
&lt;code class="highlighter-rouge"&gt;$ qisrc create foo&lt;/code&gt; &lt;br /&gt;
 New project initialized in /home/jokla/romeo/workspace/foo 
&lt;code class="highlighter-rouge"&gt;$ qibuild configure foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Current build worktree: /home/jokla/romeo/workspace 
Build type: Debug 
* (1/1) Configuring foo 
-- The C compiler identification is GNU 4.8.2
-- The CXX compiler identification is GNU 4.8.2
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Using qibuild 3.6.2
-- Binary: foo
-- Binary: test_foo
-- Configuring done
-- Generating done
-- Build files have been written to: /home/jokla/romeo/workspace/foo/build-sys-linux-x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class="highlighter-rouge"&gt;$ qibuild make foo&lt;/code&gt;&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Current build worktree: /home/jokla/romeo/workspace 
Build type: Debug 
* (1/1) Building foo 
Scanning dependencies of target foo
[ 50%] Building CXX object CMakeFiles/foo.dir/main.cpp.o
Linking CXX executable sdk/bin/foo
[ 50%] Built target foo
Scanning dependencies of target test_foo
[100%] Building CXX object CMakeFiles/test_foo.dir/test.cpp.o
Linking CXX executable sdk/bin/test_foo
[100%] Built target test_foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;We can run the executable of the project “foo”:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;$ cd ~/romeo/workspace/foo/build-sys-linux-x86_64/sdk/bin/foo&lt;/code&gt;&lt;br /&gt;
You should see:&lt;br /&gt;
&lt;code class="highlighter-rouge"&gt;Hello, world&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References: &lt;a href="https://community.aldebaran-robotics.com/doc/1-14/dev/cpp/tutos/using_qibuild.html#cpp-tutos-using-qibuild"&gt;link1&lt;/a&gt;, &lt;a href="https://community.aldebaran-robotics.com/doc/qibuild/beginner/qibuild/aldebaran.html"&gt;link2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="using-qibuild-with-aldebaran-c-sdks"&gt;Using qibuild with Aldebaran C++ SDKs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Now we need to create a toolchain (change with your path to the file toolchain.xml you want to use. You will find it in the naoqi-sdk folder):&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ qitoolchain create toolchain_romeo /home/jokla/romeo/devtools/naoqi-sdk-2.3.0.14-linux64/toolchain.xml --default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NB: Instead of &lt;code class="highlighter-rouge"&gt;toolchain_romeo&lt;/code&gt; you can choose the name that you want. You can create also different toolchains.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If you have a new version of qibuild the procedure is slightly different:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ qitoolchain create toolchain_romeo /local/soft/naoqi-sdk/naoqi-sdk-2.3.0.14-linux64/toolchain.xml
$ qibuild add-config toolchain_romeo -t toolchain_romeo --defaul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id="optional-test"&gt;Optional Test:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Open a terminal and digit:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ cd ~/romeo/devtools/naoqi-sdk-2.3.0.14-linux64/doc/dev/cpp/examples 
$ qibuild init --interactive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Now we can configure and build the examples:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ cd core/helloworld/
$ qibuild configure -c toolchain_romeo  
$ qibuild make -c toolchain_romeo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;You can also build in release mode:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;$ qibuild configure --release &amp;lt;project_name&amp;gt;
$ qibuild make --release &amp;lt;project_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Naoqi" />
      <summary type="html">How to install the SDK C++ for Pepper, Romeo or Nao.</summary>
   </entry>
   <entry>
      <title type="html">Matlab ROS Bridge</title>
      <link href="http://alitoyserkani.me/software/matlab_ros_bridge/" rel="alternate" type="text/html" title="Matlab ROS Bridge" />
      <published>2014-12-05T00:00:00+00:00</published>
      <updated>2014-12-05T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/software/matlab_ros_bridge</id>
      <content type="html" xml:base="http://alitoyserkani.me/software/matlab_ros_bridge/">&lt;p&gt;This software consists of a set of Matlab C++ S-functions that can be used to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;synchronize simulink with the system clock, thus obtaining a soft-real-time execution;&lt;/li&gt;
  &lt;li&gt;interface simulink blocks with other ROS nodes using ROS messages.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This project is based on a work started by Martin Riedel and Riccardo Spica at the Max Plank Institute for Biological Cybernetics in Tuebingen (Germany).
This fork is currently supported by &lt;a href="mailto:riccardo.spica@irisa.fr"&gt;Riccardo Spica&lt;/a&gt; and &lt;a href="mailto:giovanni.claudio@irisa.fr"&gt;Giovanni Claudio&lt;/a&gt; at the Inria Istitute in Rennes (France).&lt;/p&gt;

&lt;p&gt;The software is released under the BSD license. See the LICENSE file in this repository for more information.&lt;/p&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Matlab" />
      <category term="Simulink" />
      <category term="ROS" />
      <summary type="html">A set of Matlab C++ S-functions that can be used to interface Simulink blocks with ROS.</summary>
   </entry>
   <entry>
      <title type="html">Romeo and ROS</title>
      <link href="http://alitoyserkani.me/robotics/ros-romeo/" rel="alternate" type="text/html" title="Romeo and ROS" />
      <published>2014-10-29T00:00:00+00:00</published>
      <updated>2014-10-29T00:00:00+00:00</updated>
      <id>http://alitoyserkani.me/robotics/ros-romeo</id>
      <content type="html" xml:base="http://alitoyserkani.me/robotics/ros-romeo/">&lt;aside class="sidebar__right"&gt;
&lt;nav class="toc"&gt;
    &lt;header&gt;&lt;h4 class="nav__title"&gt;&lt;i class="fa fa-file-text"&gt;&lt;/i&gt; table of contents&lt;/h4&gt;&lt;/header&gt;
&lt;ul class="toc__menu" id="markdown-toc"&gt;
  &lt;li&gt;&lt;a href="#list-of-packages" id="markdown-toc-list-of-packages"&gt;List of packages:&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href="#step-1-controller-romeo-and--joint-state-publisher" id="markdown-toc-step-1-controller-romeo-and--joint-state-publisher"&gt;Step 1: Controller Romeo and  joint state publisher:&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#step-2-use-moveit" id="markdown-toc-step-2-use-moveit"&gt;Step 2: Use Moveit&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#calibration-camera" id="markdown-toc-calibration-camera"&gt;Calibration camera&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

  &lt;/nav&gt;
&lt;/aside&gt;

&lt;h1 id="list-of-packages"&gt;List of packages:&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/ros-aldebaran/romeo_robot"&gt;ros-aldebaran/romeo_robot&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/ros-nao/nao_sensors"&gt;ros-nao/nao_sensors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/ros-aldebaran/romeo_moveit_config"&gt;ros-aldebaran/romeo_moveit_config&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="step-1-controller-romeo-and--joint-state-publisher"&gt;Step 1: Controller Romeo and  joint state publisher:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Install the package &lt;a href="http://wiki.ros.org/ros_control"&gt;ros_control&lt;/a&gt;:
&lt;code class="highlighter-rouge"&gt;sudo apt-get install ros-indigo-ros-control ros-indigo-ros-controllers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Set AL_DIR to the path to naoqiSDK-c++ on your computer:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class="highlighter-rouge"&gt;gedit ~/.bashrc&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Add the following line setting the correct path to your naoqi-sdk-c++:
&lt;code class="highlighter-rouge"&gt;export AL_DIR=/local/soft/naoqi/naoqi-sdk-2.1.0.19-linux64&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clone the repository &lt;a href="https://github.com/ros-aldebaran/romeo_robot"&gt;ros-aldebaran/romeo_robot&lt;/a&gt; in your &lt;code class="highlighter-rouge"&gt;catkin_ws&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Go via terminal in your &lt;code class="highlighter-rouge"&gt;catkin_ws&lt;/code&gt; and build the packages with &lt;code class="highlighter-rouge"&gt;catkin_make&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Source your workspace:
 &lt;code class="highlighter-rouge"&gt;source devel/setup.bash&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now you can run:
&lt;code class="highlighter-rouge"&gt;roslaunch romeo_dcm_bringup romeo_dcm_bringup_remote.launch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="step-2-use-moveit"&gt;Step 2: Use Moveit&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Follow the Step 1&lt;/li&gt;
  &lt;li&gt;Install Moveit in Indigo:
    &lt;ul&gt;
      &lt;li&gt;Open synaptic package manager and search for &lt;code class="highlighter-rouge"&gt;moveit&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Install the packages you find (I don’t know exactly with packages are required so I installed all of them, except those with &lt;code class="highlighter-rouge"&gt;config&lt;/code&gt; )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clone in your repository &lt;a href="https://github.com/ros-aldebaran/romeo_moveit_config"&gt;ros-aldebaran/romeo_moveit_config&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Go via terminal in your &lt;code class="highlighter-rouge"&gt;catkin_ws&lt;/code&gt; and build the packages with &lt;code class="highlighter-rouge"&gt;catkin_make&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Source your workspace:
 &lt;code class="highlighter-rouge"&gt;source devel/setup.bash&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Now we can run the &lt;code class="highlighter-rouge"&gt;dcm_bringup&lt;/code&gt;
&lt;code class="highlighter-rouge"&gt;roslaunch romeo_dcm_bringup romeo_dcm_bringup_remote.launch&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Wait until &lt;code class="highlighter-rouge"&gt;romeo_dcm_bringup&lt;/code&gt; node is ready, then run MoveIt:
 &lt;code class="highlighter-rouge"&gt;roslaunch romeo_moveit_config moveit_planner_romeo.launch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="calibration-camera"&gt;Calibration camera&lt;/h2&gt;
&lt;p&gt;Calibrate the camera: 
&lt;code class="highlighter-rouge"&gt;rosrun camera_calibration cameracalibrator.py --size 9x6 --square 0.025 --no-service-check&lt;/code&gt;
&lt;code class="highlighter-rouge"&gt;image:=/nao_camera/image_raw camera:=/nao_camera&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/camera_calibration/Tutorials/MonocularCalibration&lt;/p&gt;

&lt;p&gt;To converver ini to yaml:&lt;/p&gt;

&lt;p&gt;http://wiki.ros.org/camera_calibration_parsers&lt;/p&gt;</content>
      <author>
         <name>Ali Toyserkani</name>
      </author>
      <category term="Romeo" />
      <category term="ROS" />
      <summary type="html">How to control Romeo via ROS.</summary>
   </entry>
</feed>